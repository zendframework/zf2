<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<section 
    xmlns="http://docbook.org/ns/docbook" version="5.0" 
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xml:id="zend.form.quick-start">
    <info><title>Zend\Form Quick Start</title></info>

    <para>
        Forms are relatively easy to create. At the bare minimum, each element or fieldset requires
        a name; typically, you'll also provide some attributes to hint to the view layer how it
        might render the item. The form itself will also typically compose an <classname
            linkend="zend.input-filter">InputFilter</classname> -- which you can also conveniently
        create directly in the form via a factory. Individual elements can hint as to what defaults
        to use when generating a related input for the input filter.
    </para>

    <para>
        Form validation is as easy as providing an array of data to the
        <methodname>setData()</methodname> method. If you want to simplify your work even more, you
        can bind an object to the form; on successful validation, it will be populated from the
        validated values.
    </para>

    <example xml:id="zend.form.quick-start.programmatic">
        <info><title>Programmatic Form Creation</title></info>

        <para>
            If nothing else, you can simply start creating elements, fieldsets, and forms and wiring
            them together.
        </para>

        <programlisting language="php"><![CDATA[
use Zend\Captcha;
use Zend\Form\Element;
use Zend\Form\Fieldset;
use Zend\Form\Form;
use Zend\InputFilter\Input;
use Zend\InputFilter\InputFilter;

$name = new Element('name');
$name->setAttributes(array(
    'type'  => 'text',
    'label' => 'Your name',
));

$email = new Element('email');
$email->setAttributes(array(
    'type'  => 'email',
    'label' => 'Your email address',
));

$subject = new Element('subject');
$subject->setAttributes(array(
    'type'  => 'text',
    'label' => 'Subject',
));

$message = new Element('message');
$message->setAttributes(array(
    'type'  => 'textarea',
    'label' => 'Message',
));

$captcha = new Element\Captcha('captcha');
$captcha->setCaptcha(new Captcha\Dumb());
$captcha->setAttributes(array(
    'label' => 'Please verify you are human',
));

$csrf = new Element\Csrf('security');

$submit = new Element('send');
$submit->setAttributes(array(
    'type'  => 'submit',
    'label' => 'Send',
));


$form = new Form('contact');
$form->addElement($name);
$form->addElement($email);
$form->addElement($subject);
$form->addElement($message);
$form->addElement($captcha);
$form->addElement($csrf);
$form->addElement($send);

$nameInput = new Input('name');
// configure input... and all others
$inputFilter = new InputFilter();
// attach all inputs

$form->setInputFilter($inputFilter);
]]></programlisting>
    
        <para>
            As you can see, this can be tedious.
        </para>
    </example>

    <example xml:id="zend.form.quick-start.factory">
        <info><title>Creation via Factory</title></info>

        <para>
            You can create the entire form, and input filter, using the
            <classname>Factory</classname>. This is particularly nice if you want to store your
            forms as pure configuration; you can simply pass the configuration to the factory and be
            done.
        </para>

        <programlisting language="php"><![CDATA[
use Zend\Form\Factory;
$factory = new Factory();
$form    = $factory->createForm(array(
    'hydrator' => 'Zend\Stdlib\Hydrator\ArraySerializable'
    'elements' => array(
        array(
            'name' => 'name',
            'attributes' => array(
                'type'  => 'text',
                'label' => 'Your name',
            ),
        ),
        array(
            'name' => 'email',
            'attributes' => array(
                'type'  => 'email',
                'label' => 'Your email address',
            ),
        ),
        array(
            'name' => 'subject',
            'attributes' => array(
                'type'  => 'text',
                'label' => 'Subject',
            ),
        ),
        array(
            'name' => 'message',
            'attributes' => array(
                'type'  => 'textarea',
                'label' => 'Message',
            ),
        ),
        array(
            'type' => 'Zend\Form\Element\Captcha',
            'name' => 'captcha',
            'attributes' => array(
                'label' => 'Please verify you are human',
                'captcha => array(
                    'class' => 'Dumb',
                ),
            ),
        ),
        array(
            'type' => 'Zend\Form\Element\Csrf',
            'name' => 'security',
        ),
        array(
            'name' => 'send',
            'attributes' => array(
                'type'  => 'submit',
                'label' => 'Send',
            ),
        ),
    ),
    /* If we had fieldsets, they'd go here; fieldsets contain
     * "elements" and "fieldsets" keys, and potentially a "type"
     * key indicating the specific FieldsetInterface 
     * implementation to use.
    'fieldsets' => array(
    ),
     */

    // Configuration to pass on to 
    // Zend\InputFilter\Factory::createInputFilter()
    'input_filter' => array(
        /* ... */
    ),
));
]]></programlisting>

        <para>
            The chief benefits to using the <classname>Factory</classname> are allowing you to store
            definitions in configuration, and usage of significant whitespace.
        </para>
    </example>

    <example xml:id="zend.form.quick-start.extension">
        <info><title>Factory-backed Form Extension</title></info>

        <para>
            The default <classname>Form</classname> implementation is backed by the
            <classname>Factory</classname>. This allows you to extend it, and define your form
            internally. This has the benefit of allowing a mixture of programmatic and
            factory-backed creation, as well as defining a form for re-use in your application.
        </para>

        <programlisting language="php"><![CDATA[
namespace Contact;

use Zend\Captcha\AdapterInterface as CaptchaAdapter;
use Zend\Form\Element;
use Zend\Form\Form;

class ContactForm extends Form
{
    protected $captcha;

    public function setCaptcha(CaptchaAdapter $captcha)
    {
        $this->captcha = $captcha;
    }

    public function prepareElements()
    {
        // add() can take either an Element/Fieldset instance, 
        // or a specification, from which the appropriate object
        // will be built.

        $this->add(array(
            'name' => 'name',
            'attributes' => array(
                'type'  => 'text',
                'label' => 'Your name',
            ),
        ));
        $this->add(array(
            'name' => 'email',
            'attributes' => array(
                'type'  => 'email',
                'label' => 'Your email address',
            ),
        ));
        $this->add(array(
            'name' => 'subject',
            'attributes' => array(
                'type'  => 'text',
                'label' => 'Subject',
            ),
        ));
        $this->add(array(
            'name' => 'message',
            'attributes' => array(
                'type'  => 'textarea',
                'label' => 'Message',
            ),
        ));
        $this->add(array(
            'type' => 'Zend\Form\Element\Captcha',
            'name' => 'captcha',
            'attributes' => array(
                'label' => 'Please verify you are human',
                'captcha => $this->captcha,
            ),
        )),
        $this->add(new Element\Csrf('security'));
        $this->add(array(
            'name' => 'send',
            'attributes' => array(
                'type'  => 'submit',
                'label' => 'Send',
            ),
        ));

        // We could also define the input filter here, or
        // lazy-create it in the getInputFilter() method.
    }
));
]]></programlisting>

        <para>
            You'll note that this example introduces a method,
            <methodname>prepareElements()</methodname>. This is done to allow altering and/or
            configuring either the form or input filter factory instances, which could then have
            bearing on how elements, inputs, etc. are created. In this case, it also allows
            injection of the CAPTCHA adapter, allowing us to configure it elsewhere in our
            application and inject it into the form.
        </para>
    </example>

    <example xml:id="zend.form.quick-start.validation">
        <info><title>Validating Forms</title></info>

        <para>
            Validating forms requires three steps. First, the form must have an input filter
            attached. Second, you must inject the data to validate into the form. Third, you
            validate the form. If invalid, you can retrieve the error messages, if any.
        </para>

        <programlisting language="php"><![CDATA[
$form = new Contact\ContactForm();

// If the form doesn't define an input filter by default, inject one.
$form->setInputFilter(new Contact\ContactFilter());

// Get the data. In an MVC application, you might try:
$data = $request->post();  // for POST data
$data = $request->query(); // for GET (or query string) data

$form->setData($data);

// Validate the form
if ($form->isValid() {
    $validatedData = $form->getData();
} else {
    $messages = $form->getMessages();
}
]]></programlisting>

        <para>
            You can get the raw data if you want, by accessing the composed input filter.
        </para>
    </example>

    <example xml:id="zend.form.quick-start.binding">
        <info><title>Binding an object</title></info>

        <para>
            As noted in the intro, forms in Zend Framework bridge the domain model and the view
            layer. Let's see that in action.
        </para>

        <para>
            When you <methodname>bind()</methodname> an object to the form, the following happens:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    The composed <classname>Hydrator</classname> calls
                    <methodname>extract()</methodname> on the object, and uses the values returned,
                    if any, to populate the <varname>value</varname> attributes of all elements.
                </para>
            </listitem>

            <listitem>
                <para>
                    When <methodname>isValid()</methodname> is called, if
                    <methodname>setData()</methodname> has not been previously set, the form uses
                    the composed <classname>Hydrator</classname> to extract values from the object,
                    and uses those during validation.
                </para>
            </listitem>

            <listitem>
                <para>
                    If <methodname>isValid()</methodname> is successful (and the
                    <varname>bindOnValidate</varname> flag is enabled, which is true by default),
                    then the <classname>Hydrator</classname> will be passed the validated values to
                    use to hydrate the bound object. (If you do not want this behavior, call
                    <methodname>setBindOnValidate(FormInterface::BIND_MANUAL)</methodname>).
                </para>
            </listitem>
        </itemizedlist>

        <para>
            This is easier to understand in practice.
        </para>

        <programlisting language="php"><![CDATA[
$contact = new ArrayObject;
$contact['subject'] = '[Contact Form] ';
$contact['message'] = 'Type your message here';

$form    = new Contact\ContactForm;

$form->bind($contact); // form now has default values for 
                       // 'subject' and 'message'

$data = array(
    'name'    => 'John Doe',
    'email'   => 'j.doe@example.tld',
    'subject' => '[Contact Form] \'sup?',
);
$form->setData($data);

if ($form->isValid()) {
    // $contact now looks like:
    // array(
    //     'name'    => 'John Doe',
    //     'email'   => 'j.doe@example.tld',
    //     'subject' => '[Contact Form] \'sup?',
    //     'message' => 'Type your message here',
    // )
    // only as an ArrayObject
}
]]></programlisting>

        <para>
            When an object is bound to the form, calling <methodname>getData()</methodname> will
            return that object by default. If you want to return an associative array instead, you
            can pass the <varname>FormInterface::VALUES_AS_ARRAY</varname> flag to the method.
        </para>

        <programlisting language="php"><![CDATA[
use Zend\Form\FormInterface;
$data = $form->getData(FormInterface::VALUES_AS_ARRAY);
]]></programlisting>

        <para>
            Zend Framework ships several standard <link
                linkend="zend.stdlib.hydrator">hydrators</link>, and implementation is as simple as
            implementing <classname>Zend\Stdlib\Hydrator\HydratorInterface</classname>, which looks
            like this:
        </para>

        <programlisting language="php"><![CDATA[
namespace Zend\Stdlib\Hydrator;

interface Hydrator
{
    /** @return array */
    public function extract($object);
    public function hydrate(array $data, $object);
}
]]></programlisting>
    </example>

    <example xml:id="zend.form.quick-start.rendering">
        <info><title>Rendering</title></info>

        <para>
            As noted previously, forms are meant to bridge the domain model and view layer. We've
            discussed the domain model binding, but what about the view?
        </para>

        <para>
            The form component ships a set of form-specific view helpers. These accept the various
            form objects, and introspect them in order to generate markup. Typically, they will
            inspect the attributes, but in special cases, they may look at other properties and
            composed objects.
        </para>

        <para>
            When preparing to render, you will likely want to call
            <methodname>prepare()</methodname>. This method ensures that certain injections are
            done, and will likely in the future munge names to allow for
            <varname>scoped[array][notation]</varname>.
        </para>

        <para>
            The most used and simplest view helpers available are
            <classname>Form</classname>, <classname>FormElement</classname>,
            <classname>FormLabel</classname>, and <classname>FormElementErrors</classname>. Let's
            use them to display the contact form.
        </para>

        <programlisting language="php"><![CDATA[
<?php
// within a view script
$form = $this->form;
$form->prepare();

// Assuming the "contact/process" route exists...
$form->setAttribute('action', $this->url('contact/process'));

// Set the method attribute for the form
$form->setAttribute('method', 'post');
 
// Render the opening tag
echo $this->form()->openTag($form);
?>
<div class="form_element">
<?php 
    $name = $form->get('name');
    echo $this->formLabel()->openTag($name);
    echo $this->formInput($name);
    echo $this->formElementErrors($name);
    echo $this->formLabel()->closeTag();
?></div>
 
<div class="form_element">
<?php 
    $subject = $form->get('subject');
    echo $this->formLabel()->openTag($subject);
    echo $this->formInput($subject);
    echo $this->formElementErrors($subject);
    echo $this->formLabel()->closeTag();
?></div>
 
<div class="form_element">
<?php 
    $message = $form->get('message');
    echo $this->formLabel()->openTag($message);
    echo $this->formInput($message);
    echo $this->formElementErrors($message);
    echo $this->formLabel()->closeTag();
?></div>
 
<div class="form_element">
<?php 
    $captcha = $form->get('captcha');
    echo $this->formLabel()->openTag($captcha);
    echo $this->formInput($captcha);
    echo $this->formElementErrors($captcha);
    echo $this->formLabel()->closeTag();
?></div>

<?php echo $this->formElement($form->get('security') ?>
<?php echo $this->formElement($form->get('send') ?>
 
<?php echo $this->form()->closeTag() ?>
]]></programlisting>

        <para>
            There are a few things to note about this. First, to prevent confusion in IDEs and
            editors when syntax highlighting, we use helpers to both open and close the form and
            label tags. Second, there's a lot of repetition happening here; we could easily create a
            partial view script or a composite helper to reduce boilerplate. Third, note that not
            all elements are created equal -- the CSRF and submit elements don't need labels or
            error messages necessarily. Finally, note that the <classname>FormElement</classname>
            helper tries to do the right thing -- it delegates actual markup generation toother view
            helpers; however, it can only guess what specific form helper to delegate to based on
            the list it has. If you introduce new form view helpers, you'll need to extend the
            <classname>FormElement</classname> helper, or create your own.
        </para>

        <para>
            Currently, the complete list of available form helpers is:
            <classname>FormCaptcha</classname>, 
            <classname>FormInput</classname> (which handles any type that the input HTML element
            accepts), <classname>FormMultiCheckbox</classname> (for creating sets of related
            checkboxes), <classname>FormRadio</classname>, <classname>FormSelect</classname>
            (which can also handle optgroups), and <classname>FormTextarea</classname>.
        </para>

        <para>
            In order to use these form view helpers in the first place, you need to inform the
            helper loader about them. The easiest way to do this is in your configuration; simply
            add an entry for <classname>Zend\Form\View\HelperLoader</classname> to the
            <varname>helper_map</varname> key of the <varname>view_manager</varname> configuration:
        </para>

        <programlisting language="php"><![CDATA[
// In some module configuration, or a config/autoload/ configuration file:
return array(
    'view_manager' => array(
        'helper_map' => array(
            'Zend\Form\View\HelperLoader,
        ),
    ),
);
]]></programlisting>
    </example>

    <example xml:id="zend.form.quick-start.partial">
        <info><title>Validation Groups</title></info>

        <para>
            Sometimes you want to validate only a subset of form elements. As an example, let's say
            we're re-using our contact form over a web service; in this case, the
            <classname>Csrf</classname>, <classname>Captcha</classname>, and submit button elements
            are not of interest, and shouldn't be validated.
        </para>

        <para>
            <classname>Zend\Form</classname> provides a proxy method to the underlying
            <classname>InputFilter</classname>'s <methodname>setValidationGroup()</methodname>
            method, allowing us to perform this operation.
        </para>

        <programlisting language="php"><![CDATA[
$form->setValidationGroup('name', 'email', 'subject', 'message');
$form->setData($data);
if ($form->isValid()) {
    // Contains only the "name", "email", "subject", and "message" values
    $data = $form->getData();
}
]]></programlisting>

        <para>
            If you later want to reset the form to validate all, simply pass the
            <varname>FormInterface::VALIDATE_ALL</varname> flag to the
            <methodname>setValidationGroup()</methodname> method.
        </para>

        <programlisting language="php"><![CDATA[
use Zend\Form\FormInterface;
$form->setValidationGroup(FormInterface::VALIDATE_ALL);
]]></programlisting>
    </example>
</section>
